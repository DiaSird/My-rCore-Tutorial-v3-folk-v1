use bitflags::*;

bitflags! {
    /// Signals
    /// - https://man7.org/linux/man-pages/man2/sigaction.2.html
    /// - https://venam.nixers.net/blog/unix/2016/10/21/unix-signals.html
    ///
    /// How to check all Linux signals
    ///
    /// - $kill -l
    pub struct SignalFlags: i32 {
        /// Default behavior: kill process
        const SIGDEF = 1;
        /// Hang-up, termination of controlled terminal.
        const SIGHUP = 1 << 1;
        /// signal interrupt
        /// - sent when CTRL+C is pressed in the current process.
        const SIGINT = 1 << 2;
        const SIGQUIT = 1 << 3;
        /// Exceptions to False Orders
        const SIGILL = 1 << 4;
        const SIGTRAP = 1 << 5;
        /// signal abort
        /// - Generated by a call to the abort function,
        ///   causing the process to terminate abnormally.
        const SIGABRT = 1 << 6;
        const SIGBUS = 1 << 7;
        const SIGFPE = 1 << 8;
        /// Force the process to terminate
        const SIGKILL = 1 << 9;
        /// User defined signal 1
        const SIGUSR1 = 1 << 10;
        /// signal segmentation violation
        /// - Illegal memory access exception
        const SIGSEGV = 1 << 11;
        /// User defined signal 2
        const SIGUSR2 = 1 << 12;
        const SIGPIPE = 1 << 13;
        const SIGALRM = 1 << 14;
        const SIGTERM = 1 << 15;
        const SIGSTKFLT = 1 << 16;
        /// signal child
        /// - Sent to a parent process whenever one of its child processes terminates or stops.
        const SIGCHLD = 1 << 17;
        /// signal continue
        /// - Signal to cancel pause
        const SIGCONT = 1 << 18;
        /// signal stop
        /// - Suspends the process
        const SIGSTOP = 1 << 19;
        /// `CTRL+Z` key pressed in current process will be sent to current process to pause
        const SIGTSTP = 1 << 20;
        const SIGTTIN = 1 << 21;
        const SIGTTOU = 1 << 22;
        const SIGURG = 1 << 23;
        const SIGXCPU = 1 << 24;
        const SIGXFSZ = 1 << 25;
        const SIGVTALRM = 1 << 26;
        const SIGPROF = 1 << 27;
        const SIGWINCH = 1 << 28;
        const SIGIO = 1 << 29;
        const SIGPWR = 1 << 30;
        const SIGSYS = 1 << 31;
    }
}

impl SignalFlags {
    /// If the signal representing the error is in the current signals (self == SignalFlags) => return (- `signum`, description)
    pub fn check_error(&self) -> Option<(i32, &'static str)> {
        if self.contains(Self::SIGINT) {
            Some((-2, "Killed, SIGINT=2"))
        } else if self.contains(Self::SIGILL) {
            Some((-4, "Illegal Instruction, SIGILL=4"))
        } else if self.contains(Self::SIGABRT) {
            Some((-6, "Aborted, SIGABRT=6"))
        } else if self.contains(Self::SIGFPE) {
            Some((-8, "Erroneous Arithmetic Operation, SIGFPE=8"))
        } else if self.contains(Self::SIGKILL) {
            Some((-9, "Killed, SIGKILL=9"))
        } else if self.contains(Self::SIGSEGV) {
            Some((-11, "Segmentation Fault, SIGSEGV=11"))
        } else {
            //println!("[K] signalFlags check_error  {:?}", self);
            None
        }
    }
}
